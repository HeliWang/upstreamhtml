<!doctype html>
<html><head><title>Chapter 04: Data Structure I - Sequence</title><meta charset="UTF-8"><link href="http://fonts.googleapis.com/css?family=Crimson+Text:400,400italic,700,700italic|Roboto:400,700,700italic,400italic" rel="stylesheet" type="text/css"><style>/*
 * Copyright 2014 Quip
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

body {
    font-size: 15px;
    color: #333;
    background: white;
    padding: 60px 95px;
    max-width: 900px;
    margin: 0 auto;
    text-rendering: optimizeLegibility;
    font-feature-settings: "kern";
    font-kerning: normal;
    -moz-font-feature-settings: "kern";
    -webkit-font-feature-settings: "kern";
}

/* Headings */
h1,
h2,
h3,
th {
    font-family: Roboto, sans-serif;
    font-weight: 700;
    margin: 0;
    margin-top: 1.25em;
    margin-bottom: 0.75em;
}

h1 {
    font-size: 35px;
    line-height: 42px;
}

h1:first-child {
    margin-top: 0;
}

h2 {
    font-size: 18px;
    line-height: 22px;
}

h3 {
    font-size: 13px;
    line-height: 16px;
}

.capitalize-h3 h3 {
    text-transform: uppercase;
}

/* Body text */
body,
p,
ul,
ol,
td {
    font-family: "Crimson Text", serif;
    font-size: 16px;
    line-height: 20px;
}

blockquote,
q {
    display: block;
    margin: 1em 0;
    font-style: italic;
}

blockquote a,
q a {
    text-decoration: underline;
}

blockquote {
    padding-left: 10px;
    border-left: 4px solid #a6a6a6;
}

q {
    color: #a6a6a6;
    line-height: 40px;
    font-size: 24px;
    text-align: center;
    quotes: none;
}

q a {
    color: #a6a6a6;
}

code,
pre {
    font-family: Consolas, "Liberation Mono", Menlo, "Courier Prime Web",
        Courier, monospace;
    background: #f2f2f2;
}

code {
    padding: 1px;
    margin: 0 -1px;
    border-radius: 3px;
}

pre {
    display: block;
    line-height: 20px;
    text-shadow: 0 1px white;
    padding: 5px 5px 5px 30px;
    white-space: nowrap;
    position: relative;
    margin: 1em 0;
}

pre:before {
    content: "";
    position: absolute;
    top: 0;
    bottom: 0;
    left: 15px;
    border-left: solid 1px #dadada;
}

/* Lists */
div[data-section-style="5"],
div[data-section-style="6"],
div[data-section-style="7"] {
    margin: 12px 0;
}

ul {
    padding: 0 0 0 40px;
}

ul li {
    margin-bottom: 0.4em;
}

/* Bulleted list */
div[data-section-style="5"] ul {
    list-style-type: disc;
}
div[data-section-style="5"] ul ul {
    list-style-type: circle;
}
div[data-section-style="5"] ul ul ul {
    list-style-type: square;
}
div[data-section-style="5"] ul ul ul ul {
    list-style-type: disc;
}
div[data-section-style="5"] ul ul ul ul ul {
    list-style-type: circle;
}
div[data-section-style="5"] ul ul ul ul ul ul {
    list-style-type: square;
}

/* Numbered list */
div[data-section-style="6"] ul {
    list-style-type: decimal;
}
div[data-section-style="6"] ul ul {
    list-style-type: lower-alpha;
}
div[data-section-style="6"] ul ul ul {
    list-style-type: lower-roman;
}
div[data-section-style="6"] ul ul ul ul {
    list-style-type: decimal;
}
div[data-section-style="6"] ul ul ul ul ul {
    list-style-type: lower-alpha;
}
div[data-section-style="6"] ul ul ul ul ul ul {
    list-style-type: lower-roman;
}

/* Checklist */
div[data-section-style="7"] ul {
    list-style-type: none;
}

div[data-section-style="7"] ul li:before {
    content: "\2610";
    position: absolute;
    display: inline;
    margin-right: 1.2em;
    margin-left: -1.2em;
}

div[data-section-style="7"] ul li.parent:before {
    content: "";
}

div[data-section-style="7"] ul li.checked {
    text-decoration: line-through;
}

div[data-section-style="7"] ul li.checked:before {
    content: "\2611";
    text-decoration: none;
}

/* Tables */
div[data-section-style="8"] {
    margin: 12px 0;
}

table {
    border-spacing: 0;
    border-collapse: separate;
    border: solid 1px #bbb;
    table-layout: fixed;
    position: relative;
}

table th,
table td {
    padding: 2px 2px 0;
    min-width: 1.5em;
    word-wrap: break-word;
}

table th {
    border-bottom: 1px solid #c7cbd1;
    background: #f2f2f2;
    font-weight: bold;
    vertical-align: bottom;
    color: #3a4449;
    text-align: center;
}

table td {
    padding-top: 0;
    border-left: 1px solid #c7cbd1;
    border-top: 1px solid #c7cbd1;
    vertical-align: top;
}

table td.bold {
    font-weight: bold;
}

table td.italic {
    font-style: italic;
}

table td.underline {
    text-decoration: underline;
}

table td.strikethrough {
    text-decoration: line-through;
}

table td.underline.strikethrough {
    text-decoration: underline line-through;
}

table td:first-child {
    border-left: hidden;
}

table tr:first-child td {
    border-top: hidden;
}

/* Images */
div[data-section-style="11"] {
    margin-top: 20px;
    margin-bottom: 20px;
    margin-left: auto;
    margin-right: auto;
}

div[data-section-style="11"][data-section-float="0"] {
    clear: both;
    text-align: center;
}

div[data-section-style="11"][data-section-float="1"] {
    float: left;
    clear: left;
    margin-right: 20px;
}

div[data-section-style="11"][data-section-float="2"] {
    float: right;
    clear: right;
    margin-left: 20px;
}

div[data-section-style="11"] img {
    display: block;
    max-width: 100%;
    height: auto;
    margin: auto;
}

hr {
    width: 70px;
    margin: 20px auto;
}

/* Apps */
div[data-section-style="19"].placeholder {
    margin: 0.8em auto;
    padding: 4px 0;
    display: block;
    color: #3d87f5;
    text-align: center;
    border: 1px solid rgba(41, 182, 242, 0.2);
    border-radius: 3px;
    background: #e9f8fe;
    font-family: Roboto, sans-serif;
}

div[data-section-style="19"].first-party-element {
    margin-bottom: 10px;
    background-repeat: no-repeat;
    background-size: contain;
}

div[data-section-style="19"].first-party-element.kanban {
    background-image: url("https://quip-cdn.com/nK0hSyhsb4jrLIL2s5Ma-g");
    height: 166px;
}

div[data-section-style="19"].first-party-element.calendar {
    background-image: url("https://quip-cdn.com/OYujqLny03RILxcLIiyERg");
    height: 244px;
}

div[data-section-style="19"].first-party-element.poll {
    background-image: url("https://quip-cdn.com/fbIiFrcKGv__4NB7CBfxoA");
    height: 116px;
}

div[data-section-style="19"].first-party-element.countdown {
    background-image: url("https://quip-cdn.com/3bPhykD2dBei9sSjCWteTQ");
    height: 96px;
}

div[data-section-style="19"].first-party-element.process_bar {
    background-image: url("https://quip-cdn.com/ybQlHnHEIIBLog5rZmYs_w");
    height: 36px;
}

div[data-section-style="19"].first-party-element.project_tracker {
    background-image: url("https://quip-cdn.com/OFQU087b4Mxzz1ZaHwtjXA");
    height: 164px;
}

div[data-section-style="19"] img {
    margin: 0.5em;
}

div[data-section-style="19"] img.masked-image {
    margin: 0;
    transform-origin: top left;
}

div[data-section-style="19"] .image-mask {
    position: relative;
    overflow: hidden;
}
h3 {
    text-transform: uppercase;
}
div[data-section-style="7"] ul li.parent {
    font-weight: bold;
}
</style></head><body><h1 id='VCCACAzMzOF'>Chapter 04: Data Structure I - Sequence</h1>

<h2 id='VCCACA0fFSm'>Topic 1: <b>Sorted List</b></h2>

Requirement: Approach the problem with both bottom-up and top-down algorithms. You will be expected to know the complexity of an algorithm and how you can improve/change it. Algorithms that are used to solve  problems include sorting (plus searching and binary search), divide-and-conquer, dynamic programming/memoization, greediness, recursion or algorithms linked to a specific data structure. Know Big-O notations (e.g. run time) and be ready to discuss complex algorithms like Dijkstra and A*. We recommend discussing or outlining the algorithm you have in mind before writing code. You should know the details of at least one n*log(n) sorting algorithm, preferably two (e.g. quicksort and merge sort ). Merge sort can be highly useful in situations where quicksort is impractical.<br/>

<h3 id='VCCACAVvcsi'>1.1 <b>Binary Search</b></h3>

<b>Binary Search Template - Search for a number</b><br/>

<pre id='VCCACAQ91Z8'>def binary_search(self, nums, target):    <br>    if len(nums) == 0:<br>        return -1<br>    <b>start</b><b>, end</b> = 0, len(nums) - 1<br>    <u><i><b>while start &lt; end - 1:</b></i></u><br>        <u><i><b>mid </b></i></u><u><i><b>= (start + end) / 2</b></i></u><br>        if target &gt; nums[mid]:<br>            <u><i><b>start </b></i></u><u><i><b>= mid</b></i></u><br>        else:<br>            <u><i><b>end =</b></i></u><u><i><b> mid</b></i></u>  <br>    if nums[start] == target:<br>        return start<br>    if nums[end] == target:<br>        return end<br>    return -1<br>    <br>    <br>    <br>    <br>    # Returns index of x in arr if present, else -1 <br>def binarySearch (arr, l, r, x):<br>    # Check base case <br>    if r &gt;= l: <br>        mid = (r + l) // 2<br>  <br>        # If element is present at the middle itself <br>        if arr[mid] == x: <br>            return mid <br>          <br>        # If element is smaller than mid, then it  <br>        # can only be present in left subarray <br>        elif arr[mid] &gt; x: <br>            return binarySearch(arr, l, mid-1, x) <br>  <br>        # Else the element can only be present  <br>        # in right subarray <br>        else: <br>            return binarySearch(arr, mid+1, r, x) <br>  <br>    else: <br>        # Element is not present in the array <br>        return -1<br>  <br># Test array <br>arr = [ 2, 3, 4, 10, 40 ] <br>x = 10<br>  <br># Function call <br>result = binarySearch(arr, 0, len(arr)-1, x) <br>  <br>if result != -1: <br>    print "Element is present at index %d" % result <br>else: <br>    print "Element is not present in array"</pre>

知识点<br>1. 二分位置 之 OOXX: 一般会给你一个数组. 让你找数组中第一个/最后一个满足某个条件的位置.<br>2. 二分位置 之 Half half: 并无法找到一个数组，形成 OOXX 的模型。<br>     但可以根据判断，保留下有解的那一半或者去掉无解的一半.<br/>

<br/>

<b>Example: Find Minimum in Rotated Sorted Array II</b><br/>

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br/>

(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).<br/>

Find the minimum element.<br/>

The array may contain duplicates.<br/>

<pre id='VCCACAOKvd8'>class Solution(object):<br>    def findMin(self, n MNMums):<br>        """<br>        :type nums: List[int]<br>        :rtype: int<br>        [6,7,0,1,2,4,5]<br>        [4,5,6,7,0,1,2]<br>        [2,4,5,6,7,0,1]<br>        <br>        Special Case: [3,3,3,3,3,3,3,3,1,3]<br>        """<br>        if not nums: return None<br>        i = 0<br>        j = len(nums) - 1<br>        while i &lt; j - 1:<br>            mid = (i + j) // 2<br>            if nums[mid] &lt;= nums[mid + 1] &lt; nums[j]<br>                    or nums[mid] &lt; nums[mid + 1] &lt;= nums[j]:<br>                j = mid<br>            elif nums[mid] != nums[j]:<br>                i = mid<br>            else:<br>                return min(nums[i:j+1])<br>        return min(nums[i], nums[j])</pre>

<h3 id='VCCACApoSqw'><b>1.2 2-Sum / 3-Sum</b></h3>

<b>2-Sum Left Right Template <b>- Search for a sum</b></b><br/>

Given an array of sorted integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.<br/>

<pre id='VCCACAzXuBV'>class App:<br>    def twoSum(self, nums, target): <br>        #rtype: List[int] -- two indexes<br>        left, right = 0, len(nums) - 1<br>        <u><i><b>while left &lt; right:</b></i></u><br>            <u><i><b>cur_sum </b></i></u><u><i><b>= nums[left] + nums[right]</b></i></u><br>            if cur_sum &lt; target:<br>                left  += 1<br>            elif cur_sum &gt; target:<br>                right -= 1<br>            else:<br>                return left, right<br>        return -1</pre>

Related: 3Sum Smaller<br/>

Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target<br/>

<pre id='VCCACAVIUAL'>class App(object):<br>    def threeSumSmaller(self, nums, target):<br>        nums = sorted(nums)<br>        result = 0<br>        for i, n in enumerate(nums):<br>            subtarget = target - n<br>            <i><u>left  </u></i><i><u>= i + 1</u></i><br>            # meaning: everything between i (exclusive) and left (exclusive) are satisfying <br>            #    nums[left] + nums[right] &lt; subtarget<br>            <i><u>right </u></i><i><u>= len(nums) - 1</u></i><br>            <u><i><b>while left &lt; right:</b></i></u><br>                if nums[left] + nums[right] &lt; subtarget:<br>                    <b><u><i>result </i></u></b><b><u><i>+= right - left</i></u></b><br>                    left += 1<br>                else:<br>                    right -= 1<br>        return result<br>        <br>    def threeSumSmallerInnerWhile(self, nums, target):<br>        nums = sorted(nums)<br>        result = 0<br>        for i, n in enumerate(nums):<br>            subtarget = target - n<br>            <i><u>left  </u></i><i><u>= i + 1</u></i><br>            # meaning: everything between i (exclusive) and left (exclusive) are satisfying <br>            #    nums[left] + nums[right] &lt; subtarget<br>            <i><u>right </u></i><i><u>= len(nums) - 1</u></i><br>            while left &lt; right:<br>                <code><i><u><b>while left &lt; right </b></u></i>and</code> nums[left] + nums[right] &lt; subtarget: <br>                    # must have while left &lt; right!!!!<br>                    <b><u><i>result </i></u></b><b><u><i>+= right - left</i></u></b><br>                    left += 1<br>                right -= 1<br>        return result</pre>

Related: Two Sum for general unsorted array<br/>

<pre id='VCCACA2k2hx'>class App:kIolioiu </pre>

   def twoSum(self, nums, target): #rtype: List[int] -- two indexes<br>        nums = [(v, i) for i, v in enumerate(nums)]<br>        nums = sorted(nums, key = lambda x: x[0])<br>        left, right = 0, len(nums) - 1<br>        while left &lt; right:<br>            cur_sum = nums[left][0] + nums[right][0]<br>            if cur_sum &lt; target:<br>                left  += 1<br>            elif cur_sum &gt; target:<br>                right -= 1<br>            else:<br>                return nums[left][1], nums[right][1]<br>        return -1<br/>

<pre id='VCCACAmo8Os'># Two Sum III - Data structure design<br>class TwoSum:<br>    def __init__(self):<br>        self.uni_nums = set()<br>        self.dup_nums = set()<br>        <br>    def add(self, number):<br>        """<br>        Add the number to an internal data structure..<br>        :type nnb , umber: int<br>        :rtype: void<br>        <br>        """<br>        if number not in self.uni_nums:<br>            self.uni_nums.add(number)<br>        else:<br>            if number not in self.dup_nums:<br>                self.dup_nums.add(number)<br>        <br>    def find(self, value):<br>        """<br>        Find if there exists any pair of numbers which sum is equal to the value.<br>        :type value: int<br>        :rtype: bool<br>        """<br>        if value / 2 in self.dup_nums:<br>            return True<br>        else:<br>            for number in self.uni_nums:<br>                if value - number in self.uni_nums and number != value - number:<br>                    return True<br>            return False</pre>

3-SUM: Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br/>

<pre id='VCCACAcvHW4'>class App(object):<br>    def twoSum(self, nums, first_num, start, end, results):<br>        target = 0 - first_num<br>        left, right = start, end<br>        while left &lt; right:<br>            cur_sum = nums[left] + nums[right]<br>            if cur_sum &lt; target:<br>                left  += 1<br>            elif cur_sum &gt; target:<br>                right -= 1<br>            else:<br>                results.append([first_num, nums[left], nums[right]])<br>                while left &lt; right and nums[left + 1] == nums[left]:<br>                    left += 1<br>                left += 1<br>                    <br>    def threeSum(self, nums):<br>        results = []<br>        nums.sort()<br>        for i, num in enumerate(nums):<br>            if i &gt; 0 and num == nums[i - 1]:<br>                continue<br>            self.twoSum(nums, num, i + 1, len(nums) - 1, results)<br>        return results</pre>

3-SUM Follow-up — Get all possible results<br/>

<pre id='VCCACAXvpgl'>#3sum，但是一个数可以加它本身<br>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums,int target) {<br>        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        for (int i = 0 ; i &lt; nums.length; i++) {<br>            if (i != 0 &amp;&amp; nums == nums[i - 1]) continue;<br>            int left = i ;<br>            int right = nums.length - 1;<br>            while (left &lt;= right){<br>            if (nums + nums[left] + nums[right] == target) {<br>                res.add(Arrays.asList(nums,nums[left++] , nums[right--]));<br>                while(left &lt;= right &amp;&amp;nums[left] == nums[left - 1]) left ++;<br>                while(left &lt;= right &amp;&amp; nums[right] == nums[right + 1]) right --;    <br>            }<br>        else if (nums + nums[left] + nums[right] &lt; target)<br>            left ++;<br>        else<br>            right--;<br>       }<br>    }   <br>     return res;<br>}</pre>

<h3 id='VCCACAMVEzv'><b>1.3 Sorting</b></h3>

Merge Sort 比较stable, worst case 不需要shuffle也是o(nlogn)<br/>

<br/>

Example: Car Fleet<br/>

<code>N</code> cars are going to the same destination along a one lane road. The destination is <code>target</code> miles away.<br/>

Each car <code>i</code> has a constant speed <code>speed[i]</code> (in miles per hour), and initial position <code>position[i]</code> miles towards the target along the road.<br/>

A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.<br/>

The distance between these two cars is ignored - they are assumed to have the same position.<br/>

A <i>car fleet</i> is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.<br/>

If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.<br/>

<br>How many car fleets will arrive at the destination?<br/>

<pre id='VCCACAm06yI'><b>Input: </b>target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]<br><b>Output: </b>3<br><b>Explanation</b>:<br>The cars starting at 10 and 8 become a fleet, meeting each other at 12.<br>The car starting at 0 doesn't catch up to any other car, so it is a fleet by itself.<br>The cars starting at 5 and 3 become a fleet, meeting each other at 6.<br>Note that no other cars meet these fleets before the destination, so the answer is 3.</pre>

<pre id='VCCACAgDTUE'>class Solution:<br>    def carFleet(self, target, position, speed):<br>        """<br>        :type target: int<br>        :type position: List[int]<br>        :type speed: List[int]<br>        :rtype: int<br>        """<br>        c = sorted(zip(position, speed), reverse=True)<br>        # [10,8,5,3,0], speed = [2,4,1,3,1]<br>        if not position: return 0<br>        count_fleet = 1<br>        prev = 0<br>        i = 1<br>        while i &lt; len(c):<br>            # speed cannot be zero!<br>            while i &lt; len(c) and (target - c[prev][0])<br>                                    / c[prev][1] &gt;= (target - c[i][0])  / c[i][1]:<br>                i += 1<br>            if i &lt; len(c):<br>                count_fleet += 1<br>                prev = i<br>            i += 1<br>        return count_fleet</pre>

Reflection: does my idea correct? Is there any case in violation to my idea?<br/>

<h2 id='VCCACAiguMW'>Topic 2: <b>Unsorted List</b></h2>

<h3 id='VCCACAQIyQM'><b>2.1 <b>Quick Select</b></b></h3>

<b>Quick Select Template --- Kth Smallest Element in an Array by <b>O(n) — from ranking to number</b></b><br/>

<br/>

Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example, given [3,2,1,5,6,4] and k = 2, return 5.<br>Note: You may assume k is always valid, 1 ≤ k ≤ array's length.<br><br># O(n) expected run time/ O(N^2) worst case running time + O(1) memory<br># If the array is shuffled, O(n) is guaranteed<br/>

<br/>

Worst-case performance‎: ‎О(n^2), Average performance‎: ‎O(n) By master theorem, Best-case performance‎: ‎О(n) <br>T(n) = cn + T(n/2). Average Time Complexity is reached by Master Theorem.  As in quick sort, we have to do partition in halves (Half is used for convenience, the actual partition is not exact 50%. use Random Number),<br/>

<div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/x4WA4oxye_fO8IOqzElETw?a=KMPAv0fE9leqfZSceYAEN601OzdtM3ffnKhfaA990i8a' id='VCCACA5fc2I' alt=''></img></div>quickSelect(self, nums, start, end, k):<br/>

where k is the k-th smallest element to find its value.<br/>

pivot = nums[start]<br/>

left, right = <br>    partition(nums, start, end, pivot)<br/>

<br/>

right - left can be neighbors <br/>

or right - pivot_value - left<br/>

<br/>

All the elements with index &lt;= right are &lt;= right-th element in the sorted array<br/>

<br/>

All the elements with index &gt;= left are &lt;= left-th element in the sorted array<br/>

<pre id='VCCACAsMl0z'>class App(object):<br>    def findKthLargest(self, nums, k):<br>        if not nums: return None<br>        return self.quickSelect(nums, 0, len(nums) - 1, len(nums) - k)<br>    <br>    def quickSelect(self, nums, start, end, k):<br>        pivot = nums[start]<br>        left, right = self.partition(nums, start, end, pivot)<br>        <u><b><i>if k &lt;= right:</i></b></u><br>            return self.quickSelect(nums, start, right, k)<br>        <u><i><b>elif k &gt;= left:</b></i></u><br>            return self.quickSelect(nums, left, end, k)<br>        <u><i><b>else:</b></i></u><br>            return nums[k]<br>            <br>    # all the elements with idx &lt; left are with values &lt;= povot<br>    # all the elements in the idx range []????<br>    def partition(self, nums, left, right, pivot):<br>        <u><i><b>while left &lt;= right:</b></i></u><br>            <u><i><b>while nums[left] &lt;</b></i></u><u><i><b> pivot</b></i></u> and left &lt;= right:<br>                left+=1<br>            <u><i><b>while nums[right] &gt;</b></i></u><u><i><b> pivot</b></i></u> and left &lt;= right:<br>                right-=1<br>            <u><i><b>if left &lt;= right</b></i></u>:<br>                nums[left], nums[right] = nums[right], nums[left]<br>                left+=1<br>                right-=1<br>        return left, right<br> </pre>

<h3 id='VCCACA9Wn48'><b>2.2 Tail to Head Iteration</b></h3>

<b>Shuffle List - iterate from tail to head</b><br/>

<pre id='VCCACAbVZr1'>def shuffle(nums):<br>"""<br>Returns a random shuffling of the array.<br>:rtype: List[int]<br>"""<br>for i in <u><i><b>range</b></i></u><u><i><b>(len(nums) - 1, 0, -1</b></i></u><u><i><b>)</b></i></u>:<br>    # swap arbitrary element before i (or i itself) and i<br>    <u><i><b>j </b></i></u><u><i><b>= random.randrange(i + 1)</b></i></u><br>    nums[i], nums[j] = nums[j], nums[i]<br>    # origin  = nums[j]<br>    # nums[j] = nums[i]<br>    # nums[i] = origin<br>return nums</pre>

<h3 id='VCCACAheSjv'><b>2.3 <b>Prefix-Sum</b></b></h3>

<b>Subarray Sum Series</b><br/>

<b>Example: Subarray Sum Equals K (</b>Prefix sum + Dict)<br/>

<pre id='VCCACAW1BlO'>from collections import Counter<br>class App(object):<br>    def subarraySum(self, nums, k): # rtype: int<br>        result = 0<br>        prefix_sum = 0<br>        prefix_sum_dict = Counter()<br>        prefix_sum_dict[0] = 1 # 1 1, k = 2, should return 1<br>        for i, num in enumerate(nums):<br>            prefix_sum += num<br>            result += (prefix_sum_dict[prefix_sum - k])<br>            prefix_sum_dict[prefix_sum] += 1<br>        return result</pre>

Reference: <a href="https://leetcode.com/explore/interview/card/facebook/5/round-1-phone-interview/297/">https://leetcode.com/explore/interview/card/facebook/5/round-1-phone-interview/297/</a><br/>

<br/>

Prefix sum must be for POSITIVE INTEGERS!!!!<br/>

<h3 id='VCCACAvated'><b>2.4 List &amp;<b> Pointers</b></b></h3>

One pointer: Stepping, Prefix-Sum (DP)<br/>

Two pointer Race: Check Cycle (Slow/Fast)<br/>

Two pointer Moving: Sliding Window, Quick Select (Swap)<br/>

Two pointer Range: Binary Search<br/>

List Manipulation: Two Element Swap / Flipping /Rotation (By Flipping/Swapping)<br/>

<div data-section-style='13'><table id='VCCACA6efl9' title='Sheet1' style='width: 43.2667em'><thead><tr><th class='empty' style='width: 2em'/><th id='VCCACAl83t6' class='empty' style='width: 12.2667em'>A<br/></th><th id='VCCACADnXNv' class='empty' style='width: 17.2em'>B<br/></th><th id='VCCACAjCX6Y' class='empty' style='width: 13.8em'>C<br/></th></tr></thead><tbody><tr id='VCCACAmORar'><td style='background-color:#f0f0f0'>1</td><td id='s:VCCACAmORar;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br>

<br/></td><td id='s:VCCACAmORar;VCCACAe4hmC' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>General List</b></b>

<br/></td><td id='s:VCCACAmORar;VCCACAd3W0S' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Sorted List</b></b>

<br/></td></tr><tr id='VCCACAEff2K'><td style='background-color:#f0f0f0'>2</td><td id='s:VCCACAEff2K;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Single  Pointer </b></b><b><b>Stepping</b></b>

<br/></td><td id='s:VCCACAEff2K;VCCACAe4hmC' style='background-color:#dbdbdb;text-align: left;vertical-align: top;'><br>

<br/></td><td id='s:VCCACAEff2K;VCCACAd3W0S' style='background-color:#dbdbdb;text-align: left;vertical-align: top;'><br>

<br/></td></tr><tr id='VCCACA9LkFQ'><td style='background-color:#f0f0f0'>3</td><td id='s:VCCACA9LkFQ;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Single  Pointer Stepping for </b></b><b><b>Preprocessing</b></b>

<br/></td><td id='s:VCCACA9LkFQ;VCCACAe4hmC' style='background-color:#ededed;text-align: left;vertical-align: top;'><br>Prefix-sum

<br/></td><td id='s:VCCACA9LkFQ;VCCACAd3W0S' style='background-color:#ededed;text-align: left;vertical-align: top;'><br>

<br/></td></tr><tr id='VCCACA2ul5c'><td style='background-color:#f0f0f0'>4</td><td id='s:VCCACA2ul5c;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Stepping for  two sorted arrays - merging</b></b>

<br/></td><td id='s:VCCACA2ul5c;VCCACAe4hmC' style='background-color:#dbdbdb;text-align: left;vertical-align: top;'><br>

<br/></td><td id='s:VCCACA2ul5c;VCCACAd3W0S' style='background-color:#dbdbdb;text-align: left;vertical-align: top;'><br>Merging

<br/></td></tr><tr id='VCCACAnE6ow'><td style='background-color:#f0f0f0'>5</td><td id='s:VCCACAnE6ow;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Left Forward,  Left Forward (2 Pointers Stepping)</b></b>

<br/></td><td id='s:VCCACAnE6ow;VCCACAe4hmC' style='background-color:#ededed;text-align: left;vertical-align: top;'><br>Sliding Windows

<br/></td><td id='s:VCCACAnE6ow;VCCACAd3W0S' style='background-color:#ededed;text-align: left;vertical-align: top;'><br>Find Duplication / <br>Value Difference (a[i] – a[i-1])

<br/></td></tr><tr id='VCCACA6iBv4'><td style='background-color:#f0f0f0'>6</td><td id='s:VCCACA6iBv4;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Left Forward, Right Backward (2 Pointers  Stepping) 前后指针+Swap</b></b>

<br/></td><td id='s:VCCACA6iBv4;VCCACAe4hmC' style='background-color:#dbdbdb;text-align: left;vertical-align: top;'><br>Quick Select (Value → Rank) – O(n)<br>Right is  included in the range<br>left左边是所有小于pivot的数字，right右边是所有大于pivot的数字<br>pivot = A  [(start + end) / 2]

<br/></td><td id='s:VCCACA6iBv4;VCCACAd3W0S' style='background-color:#dbdbdb;text-align: left;vertical-align: top;'><br>Two Sums  (Find two elements sum to n)

<br/></td></tr><tr id='VCCACASGRoz'><td style='background-color:#f0f0f0'>7</td><td id='s:VCCACASGRoz;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Range within  start + end pointers 前后范围二分法</b></b>

<br/></td><td id='s:VCCACASGRoz;VCCACAe4hmC' style='background-color:#ededed;text-align: left;vertical-align: top;'><br>

<br/></td><td id='s:VCCACASGRoz;VCCACAd3W0S' style='background-color:#ededed;text-align: left;vertical-align: top;'><br>Binary Search

<br/></td></tr><tr id='VCCACAUTvFc'><td style='background-color:#f0f0f0'>8</td><td id='s:VCCACAUTvFc;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Fast Pointer  + Slow Pointer</b></b>

<br/></td><td id='s:VCCACAUTvFc;VCCACAe4hmC' style='background-color:#dbdbdb;text-align: left;vertical-align: top;'><br>Check Cycles

<br/></td><td id='s:VCCACAUTvFc;VCCACAd3W0S' style='background-color:#dbdbdb;text-align: left;vertical-align: top;'><br>

<br/></td></tr><tr id='VCCACAQMz7m'><td style='background-color:#f0f0f0'>9</td><td id='s:VCCACAQMz7m;VCCACAbuTwe' style='background-color:#a5a5a5;text-align: left;vertical-align: top;'><br><b><b>Flipping</b></b><b><b>/Rotation</b></b>

<br/></td><td id='s:VCCACAQMz7m;VCCACAe4hmC' style='background-color:#ededed;text-align: left;vertical-align: top;'><br>

<br/></td><td id='s:VCCACAQMz7m;VCCACAd3W0S' style='background-color:#ededed;text-align: left;vertical-align: top;'><br>Rotate an array of n elements to the lift /  to the right

<br/></td></tr></tbody></table></div><b>Example: Rotate Array</b><br/>

<b>Move Zeros (Use Pointers as a boundry)</b><br/>

Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.<br/>

<pre id='VCCACAle0rz'>def moveZeroes(nums):<br>    i = 0<br>    for j in range(len(nums)):<br>        if nums[j]:<br>            nums[i], nums[j] = nums[j], nums[i]<br>            i += 1</pre>

<b>Minimum Window Substring (Use left + right pointers as a mini window)</b><br/>

<pre id='VCCACAvHrmv'>class Solution:<br>    def minWindow(self, s, t):<br>        need, missing = collections.Counter(t), len(t)<br>        <b>i </b><b>= 0</b><br>       <b> I </b><b>= 0</b><br>       <b> J </b><b>= sys.maxsize</b><br>        <b>for j in range(len(s</b><b>))</b>: # the starting idx (j) is 1 to point to the first char<br>            c = s[j]<br>            missing -= need[c] &gt; 0<br>            need[c] -= 1<br>            <b>if not missing:  # if condition is met     </b><br>                # push left pointer while maintain the current condition<br>                #-- left pointer is inclusive in the cur solution<br>                while i &lt;= j and <b>need</b><b>[s[i]] &lt; 0:</b> <br>                    # while i &lt;= j is optional<br>                    need[s[i]] += 1<br>                    i += 1<br>                <b># update results</b><br>                if j - i &lt;= J - I:<br>                    I, J = i, j<br>        <b>if J == sys.maxsize: return ""</b><br>        return s[I:J + 1]</pre>

Similar questions: <a href="https://leetcode.com/explore/interview/card/facebook/5/round-1-phone-interview/328/">https://leetcode.com/explore/interview/card/facebook/5/round-1-phone-interview/328/</a><br/>

<br/>

<b>Use Left, Right Pointers to Record the max value so far from left / right</b><br/>

# another option: use a list (some memory) to record the max right so far. (Space will not be O(1))<br/>

<br/>

<b>Example: Trapping Rain Water</b><br/>

Given <i>n</i> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.<br/>

<pre id='VCCACAFovD8'><b>Input:</b> [0,1,0,2,1,0,1,3,2,1,2,1] <b>Output:</b> 6</pre>

<pre id='VCCACALtJgK'>class Solution(object):<br>    def trap(self, height):<br>        n = len(height)<br>        l, r, water, minHeight = 0, n - 1, 0, 0<br>       <b> </b><b>while l &lt; r:</b><br>            <b>while l &lt;</b><b> r</b> and height[l] &lt;= minHeight:<br>                water += minHeight - height[l]<br>                l += 1<br>            while r &gt; l and height[r] &lt;= minHeight:<br>                water += minHeight - height[r]<br>                r -= 1<br>            minHeight = min(height[l], height[r])<br>        return water</pre>

<h3 id='VCCACAydIre'><b>2.5 List &amp;<b> Stack</b></b></h3>

Stack (1) 保存有效信息以便后续操作 (2)  翻转 (3) Monotonous stack 单调栈 <br/>

<u><i><b>Stack of values / indexes !</b></i></u><br/>

<br/>

<b>Example: Implement Queue using Stacks</b> - O(1) amortized<br/>

<pre id='VCCACAbJfU8'># Implement Queue using Stacks - O(1) amortized,<br># 翻转栈的运用<br>class Queue(object):<br>    def __init__(self):<br>        """<br>        initialize your data structure here.<br>        """<br>        self.inStack, self.outStack = [], []<br><br>    def push(self, x):<br>        """<br>        :type x: int<br>        :rtype: nothing<br>        """<br>        self.inStack.append(x)<br><br>    def pop(self):<br>        """<br>        :rtype: nothing<br>        """<br>        self.move()<br>        self.outStack.pop()<br><br>    def peek(self):<br>        """<br>        :rtype: int<br>        """<br>        self.move()<br>        return self.outStack[-1]<br><br>    def empty(self):<br>        """<br>        :rtype: bool<br>        """<br>        return (not self.inStack) and (not self.outStack) <br>        <br>    def move(self):<br>        """<br>        :rtype nothing<br>        """<br>        if not self.outStack:<br>            while self.inStack:<br>                self.outStack.append(self.inStack.pop())</pre>

<pre id='VCCACAL449T'># Related: Implement Stack using Queues - Push is O(n), others are O(1)<br>class MyStack:<br>    def __init__(self):<br>        self._queue = collections.deque()<br><br>    def push(self, x):<br>        q = self._queue<br>        q.append(x)<br>        for _ in range(len(q) - 1):<br>            q.append(q.popleft())<br>        <br>    def pop(self):<br>        return self._queue.popleft()<br><br>    def top(self):<br>        return self._queue[0]<br>    <br>    def empty(self):<br>        return not len(self._queue)<br>        <br># Related: Valid Parentheses<br># 保存有效信息以便后续操作<br>class Solution:<br>    def isValid(self, s):<br>        """<br>        :type s: str<br>        :rtype: bool<br>        Stack must be used here for the case <br>        Input: "([)]"<br>        Output: false<br>        """<br>        stack = []<br>        chars = "()[]{}"<br>        for c in s:<br>            q = chars.index(c)<br>            if q % 2 == 1: # use the idex of chars to indicate ()[]{}<br>                if not stack or stack.pop() != q - 1:<br>                    return False<br>            else:<br>                stack.append(q)<br>        return len(stack) == 0<br></pre>

Stack: （1）保存有效信息以便后续操作 （2） 翻转<br/>

<br/>

Monotonous stack: 单调栈 — 找每一个元素左边或者右边，第一个比自身小/大的元素<br/>

<br/>

单调栈：递增栈是维护递增的顺序，当遇到小于栈顶元素的数就开始处理，而递减栈正好相反，维护递减的顺序，当遇到大于栈顶元素的数开始处理.<br/>

<br/>

<b>单调递增栈可以找到左起第一个比当前数字小的元素</b>。比如数组 [2 1 4 6 5]，刚开始2入栈，数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，此时1入栈。那么2和1都没左起比自身小的数字。然后数字4入栈的时候，栈顶元素1小于4，于是1就是4左起第一个小的数字。此时栈里有1和4，然后数字6入栈的时候，栈顶元素4小于6，于是4就是6左起第一个小的数字。此时栈里有1，4，6，然后数字5入栈的时候，栈顶元素6大于5，将6移除，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，最终栈内数字为1，4，5。<br/>

<br/>

<b>单调递减栈可以找到左起第一个比当前数字大的元素</b>。See the example below。<br/>

递减栈会剔除波谷，留下波峰；递增栈剔除波峰，留下波谷。<br/>

<br/>

明白了单调栈的加入元素的过程后，我们来看看它的性质，以及为啥要用单调栈。单调栈的一大优势就是线性的时间复杂度，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。<br/>

<br/>

<b>Example: (LC654) Maximum Binary Tree</b><br/>

Given an integer array with no duplicates. A max tree building on this array is defined as follow:<br/>

<div data-section-style='5' style="" class=""><ul id='VCCACAF8MUC'><li id='VCCACAxpY2X' class='' value='1'>The root is the maximum number in the array

<br/></li><li id='VCCACAql3fp' class=''>The left subtree and right subtree are the max trees of the subarray divided by the root number.

<br/></li></ul></div>Construct the max tree by the given array.<br/>

<br/>

<b>Example</b><br>Given [2, 5, 6, 0, 3, 1], the max tree is<br/>

<pre id='VCCACAPZb50'>     6<br>    / \<br>   5   3<br>  /   / \<br> 2   0   1</pre>

[10, 2, 5, 3, 4, 6, 1]<br/>

<pre id='VCCACAXo1PD'>       10<br>        \<br>         6<br>        / \<br>       5   1<br>      / \<br>     2   4<br>        / <br>       3    </pre>

[3,2,1,6,0,5]<br/>

<pre id='VCCACAJ7DDe'>         6<br>      /     \<br>     3       5<br>      \     /<br>       2   0 <br>        \<br>         1<br><br> </pre>

这种树叫做笛卡树（ Cartesian tree）。直接递归建树的话复杂度最差会退化到O(n^2)。<br/>

自下而上也是经典建树方法，如2 5 6 0 3 1，2的parent肯定是比2大的元素。<br/>

让后面element主动去当前面element的children，而不是前面element找后面element去找children<br/>

For a element: <br/>

  right child: In the view of the right child, its parent is <b>its 左起第一个比当前数字大的元素</b><br/>

  left child:   The max value below the current value, which is to the right of the last peak value greater than current value<br/>

    E.g. [2, 5, 6, 0, <u><i><b>3</b></i></u>, 1] 3 should find 0 as left pointer because 0 is after 6.<br/>

<br/>

用到的是单调栈 (递减)。<br/>

Monotonic Decreasing Stack:<br/>

--- Monotic Decreasing Stack will keep<u><i><b> the max element so far</b></i></u> and all the decreasing element right after it.<br/>

  when 维护递减栈, the elements being pop are elements after last peak element below the current pushing element<br/>

  when 加入<br/>

 [2, 5, 6, 0, 3, 1]<br/>

2: [2]<br/>

5: [5]<br/>

6: [6] <br/>

0: [6, 0]<br/>

3: [6, 3]<br/>

1: [6, 3, 1]<br/>

<br/>

因为题目中构建树的要求是：<br/>

    对于每一个element，<i><u><b>找左边第一个比它小的 ()</b></u></i>，<br><b><i><u>找右边第一个比它小的 (右边递减单调栈入<b><i><u>栈时设前一个right pointer</u></i></b>)</u></i></b>，取最小。<br/>

<u><i><b>递减栈可以找到向左走第一个比当前数字大的元素</b></i></u><br/>

<pre id='VCCACABE1sH'>class Solution_simple_smart_iterative:<br>    def constructMaximumBinaryTree(self, nums):<br>        stack = []<br>        for i in range(len(nums)):<br>            cur = TreeNode(nums[i])<br>            while stack and stack[-1].val &lt; nums[i]: # 维护递减栈<br>                cur.left = stack.pop()<br>            if stack: # 递减栈可以找到向左走第一个比当前数字大的元素<br>                stack[-1].right = cur<br>            stack.append(cur)<br>        return stack[0]</pre>

<b>Example. (LC84) Largest Rectangle in Histogram</b><br/>

Given <i>n</i> non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br/>

<div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/DhN2wxeH_HqxbsE7AVBrUA?a=ANhtUAyYGalJVaWfGpku3C2ai9uyOfyoB9OA5opna0ga' id='VCCACAM8szh' alt=''></img></div><br/>

Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.<br/>

The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.<br/>

<br/>

Note: 递增stack，因为需要all recent elements above the current element since the last min element.<br/>

<u><i><b>Stack of indexes</b></i></u><br/>

<pre id='VCCACAVZAbR'><b>Input:</b> [2,1,5,6,2,3]<br><b>Output:</b> 10</pre>

<pre id='VCCACAynFnx'>class Solution(object):<br>    def largestRectangleArea(self, heights):<br>        """<br>        :type heights: List[int]<br>        :rtype: int<br>        """<br>        stack = []<br>        result = 0<br>        <i><u><b>heights</b></u></i><i><u><b>.append(0)</b></u></i><br>        for i, height in enumerate(heights):<br>            while stack and heights[stack[-1]] &gt; height:<br>                <i><u><b>idx </b></u></i><i><u><b>= stack.pop()</b></u></i><br>                last_idx = -1<br>                <i><u><b>if stack:</b></u></i><br>                    last_idx = stack[-1]<br>                result = max(result, (i - <i><u><b>last_idx</b></u></i> - 1) * <i><u><b>heights</b></u></i><i><u><b>[idx</b></u></i><i><u><b>]</b></u></i>)<br>            stack.append(i)<br>        return result</pre>

<b>Example. (LC85) Maximal Rectangle</b><br/>

Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.<br/>

<br/>

<b>Example:</b><br/>

<pre id='VCCACAkame5'><b>Input:</b><br>[<br>  ["1","0","1","0","0"],<br>  ["1","0","<b>1</b>","<b>1</b>","<b>1</b>"],<br>  ["1","1","<b>1</b>","<b>1</b>","<b>1</b>"],<br>  ["1","0","0","1","0"]<br>]<br><b>Output:</b> 6</pre>

<pre id='VCCACADbmK3'>class Solution(object):<br>    def maximalRectangle(self, matrix):<br>        """<br>        :type matrix: List[List[str]]<br>        :rtype: int<br>        """<br>        if not matrix:<br>            return 0<br>        heights = [0] * len(matrix[0])<br>        result = 0<br>        for row in matrix:<br>            for i, v in enumerate(row):<br>                if v == '0':<br>                    heights[i] = 0<br>                if v == '1':<br>                    heights[i] += 1<br>            result = max(result, self.largestRectangleArea(heights))<br>        return result<br>                <br>    def largestRectangleArea(self, heights):<br>        """<br>        :type heights: List[int]<br>        :rtype: int<br>        """<br>        stack = []<br>        result = 0<br>        heights.append(0)<br>        for i, height in enumerate(heights):<br>            # mono stack [smallest -&gt; largest]<br>            #   but storing index instead of (value, index)<br>            while stack and heights[stack[-1]] &gt; height:<br>                idx = stack.pop()<br>                last_idx = -1<br>                if stack:<br>                    last_idx = stack[-1]<br>                result = max(result, (i - last_idx - 1) * heights[idx])<br>            stack.append(i)<br>        return result</pre>

<b>Related: Maximal Square</b><br/>

<pre id='VCCACAlkF3S'>class Solution:<br>    def maximalSquare(self, matrix):<br>        """<br>        :type matrix: List[List[str]]<br>        :rtype: int<br>        <br>        matrix:<br>        1 0 1 0 0<br>        1 0 1 1 1<br>        1 1 1 1 1<br>        1 0 0 1 0<br>        m = 4, n = 5<br>        <br>        maximal_square_size:<br>        1 0 1 0 0<br>        1 0 2 2 1<br>        1 1 1 1 1<br>        1 0 0 1 0<br>        """<br>        m = len(matrix)<br>        if not m: return 0<br>        n = len(matrix[0])<br>        if not n: return 0<br>        maximal_square_size = [[int(matrix[i][j]) for j in range(n)] for i in range(m)]<br>        result = 0<br>        for i in range(m - 1, -1, -1):<br>            for j in range(n - 1, -1, -1):<br>                if not (i == m - 1 or j == n - 1) and maximal_square_size[i][j] == 1:<br>                    maximal_square_size[i][j] = min(maximal_square_size[i + 1][j], <br>                                                    maximal_square_size[i][j + 1],<br>                                                    maximal_square_size[i + 1][j + 1]) + 1<br>                result = max(result, maximal_square_size[i][j])<br>        return result ** 2</pre>

<h3 id='VCCACAykLYn'><b>2.6 List &amp;<b> Deque</b></b></h3>

<b>Example: Shortest Subarray with Sum at Least K</b><br/>

Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.<br/>

If there is no non-empty subarray with sum at least K, return -1.<br/>

Example 1: Input: A = [1], K = 1 Output: 1<br/>

Example 2: Input: A = [1,2], K = 4 Output: -1<br/>

Example 3: Input: A = [2,-1,2], K = 3 Output: 3<br/>

<pre id='VCCACA38PQ6'>from collections import deque<br>class Solution(object):<br>    def shortestSubarray(self, A, K):<br>        """<br>        :type A: List[int]<br>        :type K: int<br>        :rtype: int<br>        <br>        所以要换个思路，对于每个以i结尾的子数组，有效的开头可能有很多；<br>        暴力的方法就是遍历每个有效的开头求最小的length，<br>        但是这些有效的开头都是有重叠的，<br>        一个优化的思路就是能不能每次不遍历所有有效开头，维护一个数据结构，<br>        每次都更新这个数据结构的value，从而避免重复运算<br>        <br>        https://www.gjxhlan.me/2018/07/07/leetcode-contest-91-solution/<br>        """<br>        # 如若有比K大的数，则直接返回1<br>        if max(A) &gt;= K: return 1<br><br>        # 记录和，dp[i] = sum(A[:i])<br>        dp = [0] * (len(A)+1)<br>        for i in range(1,len(dp)):<br>            dp[i] = dp[i-1] + A[i-1]<br><br>        res = float('inf')<br>        # 初始化队列<br>        Q = deque([0]) # a deque containing all indexes<br>        # 1 2 -10 3 5 3 9,  k = 4<br>        for i in range(1,len(dp)):<br>            # 思路中第2步<br>            while Q and dp[i]-dp[Q[0]] &gt;= K:<br>                res = min(res,i-Q.popleft())<br>            # 思路中第3步<br>            while Q and  dp[i]&lt;dp[Q[-1]]: # similar to the idea of monotonic stack<br>                Q.pop()<br>            Q.append(i) <br>        return [res,-1][res==float('inf')]</pre>

<h3 id='VCCACAc3veL'><b>2.7 <b><b>Flipping </b></b><b><b>/ Rotation</b></b></b></h3>

<b>Example: Rotate Array</b><br/>

<pre id='VCCACAuHSLa'># Rotate by Reversion<br>public class Solution {<br>    public void rotate(int[] nums, int k) {<br>        k %= nums.length;<br>        reverse(nums, 0, nums.length - 1);<br>        reverse(nums, 0, k - 1);<br>        reverse(nums, k, nums.length - 1);<br>    }<br>    public void reverse(int[] nums, int start, int end) {<br>        while (start &lt; end) {<br>            int temp = nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = temp;<br>            start++;<br>            end--;<br>        }<br>    }<br>}<br><br># Rotate Only By One<br>#Function to left rotate arr[] of size n by d*/<br>def leftRotate(arr, d, n):<br>    for i in range(d):<br>        leftRotatebyOne(arr, n)<br> <br>#Function to left Rotate arr[] of size n by 1*/ <br>def leftRotatebyOne(arr, n):<br>    temp = arr[0]<br>    for i in range(n-1):<br>        arr[i] = arr[i+1]<br>    arr[n-1] = temp</pre>

<h3 id='VCCACAJEiF7'><b>2.8 <i>Continuous Nums</i></b></h3>

<i>Modify array itself as a hash map to make space complexity to be O(1).</i><br/>

<br/>

<b>Example:</b>  First Missing Positive<br/>

First Missing Positive: Given an unsorted integer array, find the smallest missing positive integer.<br/>

Example 1: Input: [1,2,0] Output: 3<br/>

Example 2: Input: [3,4,-1,1] Output: 2<br/>

Example 3: Input: [7,8,9,11,12] Output: 1<br/>

Note: Your algorithm should run in O(n) time and uses constant extra space.<br/>

<br/>

虽然不能再另外开辟非常数级的额外空间，但是可以在输入数组上就地进行swap操作。<br/>

<b>思路</b>：交换数组元素，使得数组中第i位存放数值(i+1)。最后遍历数组，寻找第一个不符合此要求的元素，返回其下标。整个过程需要遍历两次数组，复杂度为<i>O(n)</i>。---&gt; By Swap One Time, An element will be settled to the correct place. <br/>

<div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/YhjK0vNqoh7IpTxdw_MYbg?a=uUqfpJRH7AnZmLvhMG3Qvzh9bzvR7qkz16gDANu6XZka' id='VCCACA4XsKD' alt=''></img></div><pre id='VCCACA4fnB6'>class Solution {<br>public:<br>    int firstMissingPositive(int A[], int n) {<br>        int i = 0;<br>        while (i &lt; n) {<br>            if (A[i] != (i+1) &amp;&amp; A[i] &gt;= 1 &amp;&amp;<br>                 A[i] &lt;= n <u><i><b>&amp;&amp; A[A[i]-1] != A[i</b></i></u><u><i><b>]</b></i></u>)<br>                swap(A[i], A[A[i]-1]);<br>            else<br>                i++;<br>        }<br>        for (i = 0; i &lt; n; ++i)<br>            if (A[i] != (i+1))<br>                return i+1;<br>        return n+1;<br>    }<br>};</pre>

<h3 id='VCCACAiCYH2'><b>2.9 List &amp; Map &amp; Set</b></h3>

<div data-section-style='13'><table id='VCCACAWTaZV' title='Sheet2' style='width: 51.8em'><thead><tr><th class='empty' style='width: 2em'/><th id='VCCACAUUUH2' class='empty' style='width: 21.7333em'>A<br/></th><th id='VCCACAjqXrb' class='empty' style='width: 6em'>B<br/></th><th id='VCCACATJNEW' class='empty' style='width: 24.0667em'>C<br/></th></tr></thead><tbody><tr id='VCCACAqhcm5'><td style='background-color:#f0f0f0'>1</td><td id='s:VCCACAqhcm5;VCCACAbehfK' style='background-color:#eeddee;vertical-align: middle;'><br><b>Operation</b>

<br/></td><td id='s:VCCACAqhcm5;VCCACAQgNTW' style='background-color:#eeddee;vertical-align: middle;'><br><b>Equivalent</b>

<br/></td><td id='s:VCCACAqhcm5;VCCACAw6J9r' style='background-color:#eeddee;vertical-align: middle;'><br><b>Result</b>

<br/></td></tr><tr id='VCCACAMIu1a'><td style='background-color:#f0f0f0'>2</td><td id='s:VCCACAMIu1a;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code>s.pop()</code>

<br/></td><td id='s:VCCACAMIu1a;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br>

<br/></td><td id='s:VCCACAMIu1a;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br>Pop a random element from s

<br/></td></tr><tr id='VCCACAwxlS8'><td style='background-color:#f0f0f0'>3</td><td id='s:VCCACAwxlS8;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code>x in s</code>

<br/></td><td id='s:VCCACAwxlS8;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br>

<br/></td><td id='s:VCCACAwxlS8;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br>test <i>x</i> for membership in <i>s</i>

<br/></td></tr><tr id='VCCACAwTOjH'><td style='background-color:#f0f0f0'>4</td><td id='s:VCCACAwTOjH;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code>x not in s</code>

<br/></td><td id='s:VCCACAwTOjH;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br>

<br/></td><td id='s:VCCACAwTOjH;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br>test <i>x</i> for non-membership in <i>s</i>

<br/></td></tr><tr id='VCCACAesd9a'><td style='background-color:#f0f0f0'>5</td><td id='s:VCCACAesd9a;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code>s.issubset(t)</code>

<br/></td><td id='s:VCCACAesd9a;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br><code>s &lt;= t</code>

<br/></td><td id='s:VCCACAesd9a;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br>test whether every element in <i>s</i> is in <i>t</i>

<br/></td></tr><tr id='VCCACAkSkqw'><td style='background-color:#f0f0f0'>6</td><td id='s:VCCACAkSkqw;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code>s.issuperset(t)</code>

<br/></td><td id='s:VCCACAkSkqw;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br><code>s &gt;= t</code>

<br/></td><td id='s:VCCACAkSkqw;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br>test whether every element in <i>t</i> is in <i>s</i>

<br/></td></tr><tr id='VCCACAALXUt'><td style='background-color:#f0f0f0'>7</td><td id='s:VCCACAALXUt;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code><b>s.union(t)</b></code>

<br/></td><td id='s:VCCACAALXUt;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br><code><b>s | t</b></code>

<br/></td><td id='s:VCCACAALXUt;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br><b>new set with elements from both <i>s</i> and <i>t</i></b>

<br/></td></tr><tr id='VCCACAO5v7t'><td style='background-color:#f0f0f0'>8</td><td id='s:VCCACAO5v7t;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code><b>s.intersection(t)</b></code>

<br/></td><td id='s:VCCACAO5v7t;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br><code><b>s &amp; t</b></code>

<br/></td><td id='s:VCCACAO5v7t;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br><b>new set with elements common to <i>s</i> and <i>t</i></b>

<br/></td></tr><tr id='VCCACAyFxtz'><td style='background-color:#f0f0f0'>9</td><td id='s:VCCACAyFxtz;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code><b>s.difference(t)</b></code>

<br/></td><td id='s:VCCACAyFxtz;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br><code><b>s - t</b></code>

<br/></td><td id='s:VCCACAyFxtz;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br><b>new set with elements in <i>s</i> but not in <i>t</i></b>

<br/></td></tr><tr id='VCCACAilzlL'><td style='background-color:#f0f0f0'>10</td><td id='s:VCCACAilzlL;VCCACAbehfK' style='background-color:#eeeeff;vertical-align: middle;'><br><code><b>s.symmetric_difference(t)</b></code>

<br/></td><td id='s:VCCACAilzlL;VCCACAQgNTW' style='background-color:#eeeeff;vertical-align: middle;'><br><code><b>s ^ t</b></code>

<br/></td><td id='s:VCCACAilzlL;VCCACAw6J9r' style='background-color:#eeeeff;vertical-align: middle;'><br><b>new set with elements in either <i>s</i> or <i>t</i> but not both</b>

<br/></td></tr></tbody></table></div><h2 id='VCCACAAuaHO'>Topic 3: Linked List</h2>

<h3 id='VCCACAThYIi'>3.1 Get Median / Reverse</h3>

Fast Pointer, Slow Pointer ---&gt; Find median/ Tortoise and hare if there is an intersection;<br/>

Pay attention to the case when a pointer is None;<br/>

Pay attention to see if the linked list length is even or odd;<br/>

<br/>

<b>Example: Reorder List</b><br/>

Given a singly linked list <i>L</i>: <i>L</i>0→<i>L</i>1→…→<i>L</i><i>n</i>-1→<i>L</i>n,<br>reorder it to: <i>L</i>0→<i>L</i><i>n</i>→<i>L</i>1→<i>L</i><i>n</i>-1→<i>L</i>2→<i>L</i><i>n</i>-2→…<br/>

You may <b>not</b> modify the values in the list's nodes, only nodes itself may be changed.<br/>

<pre id='VCCACAxwJRj'>class Solution(object):<br>    """<br>    1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.<br>    1-&gt;2-&gt;3&lt;-4&lt;-5  <br>    1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.<br>    1-&gt;2-&gt;3&lt;-4<br>    """<br>    def reorderList(self, head):<br>        """<br>        :type head: ListNode<br>        :rtype: void Do not return anything, modify head in-place instead.<br>        """<br>        # Find the median (or next near median split) of the linked list:<br>        head_fast = head<br>        head_slow = head<br>        while head_fast and head_fast.next: <br>            # 1 -&gt; 2 -&gt; 3       head_fast will be 3 while head_slow is 2<br>            # 1 -&gt; 2 -&gt; 3 -&gt; 4  head_fast will be None while head_slow is 3<br>            head_fast = head_fast.next.next<br>            head_slow = head_slow.next<br>        <br>        # Reverse linked list since head_slow:<br>        #  1 -&gt; 2 -&gt; 3 -&gt; 4    1 -&gt; 2    4 -&gt; 3<br>        cur = None<br>        cur_next = head_slow<br>        while cur_next:<br>            cur_next_next = cur_next.next<br>            cur_next.next = cur<br>            cur      = cur_next <br>            cur_next = cur_next_next<br>        <br>        l1 = head<br>        l2 = cur<br>        # Merge head and cur<br>        while l1:<br>            next_l1 = l1.next<br>            l1.next = l2<br>            if not l2: break<br>            next_l2 = l2.next<br>            l2.next = next_l1<br>            l1      = next_l1<br>            l2      = next_l2</pre>

<b>Example: Palindrome Linked List</b><br/>

Given a singly linked list, determine if it is a palindrome.<br/>

<pre id='VCCACAMWTpM'><b>Input:</b> 1-&gt;2<br><b>Output:</b> false</pre>

<pre id='VCCACAyh8Mg'><b>Input:</b> 1-&gt;2-&gt;2-&gt;1<br><b>Output:</b> true</pre>

<pre id='VCCACAfHG4W'>/**<br> * @param {ListNode} head<br> * @return {boolean}<br> 1<br> 1-&gt;1<br> 1-&gt;2<br> 1-&gt;4-&gt;3<br> 1-&gt;4-&gt;1<br> */<br>var isPalindrome = function(head) {<br>    // know mid<br>    // reverse before mid<br>    // run backward and forward in pararrel since mid<br>    let fast = head<br>    let slow = head<br>    let slowPrev = null<br>    while (fast != null &amp;&amp; fast.next != null) { <br>        // 1-&gt;2-&gt;3 fast == 3 slow == 2 slowPrev == 1.<br>        // 1-&gt;2-&gt;3-&gt;4 fast == null slowPrev == 2, slow == 3<br>        fast = fast.next.next<br>        let actualSlowNext = slow.next<br>        slow.next = slowPrev<br>        slowPrev = slow<br>        slow = actualSlowNext<br>    }<br>    <br>    if (fast != null) { // if odd, move slow one step forward<br>        slow = slow.next<br>    }<br>    <br>    while (slow != null) {<br>        if (slow.val != slowPrev.val) {<br>            return false<br>        }<br>        slow = slow.next<br>        slowPrev = slowPrev.next<br>    }<br>    <br>    return true<br>};</pre>

<h3 id='VCCACAMDYHD'>3.2 Utilize Helpers</h3>

<b>Example: Convert Binary Search Tree to Sorted Doubly Linked List</b><br/>

Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.<br/>

Let's take the following BST as an example, it may help you understand the problem better:<br/>

<br/>

We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.<br/>

The figure below shows the circular doubly linked list for the BST above. The "head" symbol means the node it points to is the smallest element of the linked list.<br/>

<br/>

Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list.<br/>

The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.<br/>

<div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/tV1cxTxpzqK54zPMppFlfQ?a=qj4v6sR5B6uEatdCZbmSgRqDAIigkEa6hKudOady3FUa' id='VCCACA2suto' alt=''></img></div><div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/RbRCgFk7268odqJYapQi5g?a=Uat2ABhrXVpoA6fXZ2SDPadrgd4D6F2ggjUFp3GYzJYa' id='VCCACABkwCG' alt=''></img></div><br/>

<div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/srqGoZkD86qvbvuRH7hmkQ?a=YOdCya7Eralv62TnBXrMGliua4bqI7csOazScEdp128a' id='VCCACAdnOoL' alt=''></img></div><br/>

<pre id='VCCACAp3p9L'>class Solution {<br>    public Node treeToDoublyList(Node root) {<br>        if (root == null) {<br>            return null;<br>        }<br>        <br>        Node leftHead = treeToDoublyList(root.left);<br>        Node rightHead = treeToDoublyList(root.right);<br>        root.left = root;<br>        root.right = root;<br>        return connect(connect(leftHead, root), rightHead);<br>    }<br>    <br>    // Used to connect two circular doubly linked lists. <br>    // n1 is the head as well as n2.<br>    private Node connect(Node n1, Node n2) {<br>        if (n1 == null) {<br>            return n2;<br>        }<br>        <br>        if (n2 == null) {<br>            return n1;<br>        }<br>        <br>        Node tail1 = n1.left;<br>        Node tail2 = n2.left;<br>        <br>        tail1.right = n2;<br>        n2.left = tail1;<br>        tail2.right = n1;<br>        n1.left = tail2;<br>        <br>        return n1;<br>    }<br>}</pre>

<b>Example: Merge k Sorted Linked List</b><br/>

Merge <i>k</i> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br/>

Time complexity: O(n*logk)<br/>

<pre id='VCCACA3XvIV'># Definition for singly-linked list.<br># class ListNode:<br>#     def __init__(self, x):<br>#         self.val = x<br>#         self.next = None<br><br>class Solution:<br>    def conquer(self, a, b):<br>        head = cur = ListNode(None) # Dummy Node<br>        while a and b:<br>            if a.val &lt; b.val:<br>                cur.next = a<br>                a = a.next<br>            else:<br>                cur.next = b<br>                b = b.next<br>                <br>            cur = cur.next<br>            cur.next = None<br>        if a:<br>            cur.next = a<br>        if b:<br>            cur.next = b<br>        return head.next<br>    <br>    def conquer2(self, a, b):<br>        head = ListNode(None) # Dummy Node<br>        head.next = a<br>        <br>        node = head<br>        while node.next:<br>            if b and node.next.val &gt; b.val:<br>                pre_next  = node.next<br>                node.next = b<br>                b_next    = b.next<br>                b.next    = pre_next<br>                <br>                node      = b<br>                b         = b_next<br>            else:<br>                node      = node.next<br>        node.next = b<br>        return head.next<br>            <br>    def divide(self, lists, start, end):<br>        """<br>        *Input: *[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ]<br>*        Output:* 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>        """<br>        if start &gt; end: return []<br>        if start == end:<br>            return lists[start]<br>        mid   = (start + end) // 2<br>        left  = self.divide(lists, start,   mid)<br>        right = self.divide(lists, mid + 1, end)<br>        return self.conquer(left, right)<br>    <br>    def mergeKLists(self, lists):<br>        """<br>        :type lists: List[ListNode]<br>        :rtype: ListNode<br>        O R T<br>        """<br>        return self.divide(lists, 0, len(lists) - 1)</pre>

<b>Example: Populating Next Right Pointers in Each Node II</b><br/>

Given a binary tree<br/>

<pre id='VCCACAtCIir'>struct TreeLinkNode {<br>  TreeLinkNode *left;<br>  TreeLinkNode *right;<br>  TreeLinkNode *next;<br>}</pre>

<br/>

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.<br/>

Initially, all next pointers are set to <code>NULL</code>.<br/>

<b>Note:</b><br/>

<div data-section-style='5' style="" class=""><ul id='VCCACArVOgM'><li id='VCCACA8uFGl' class='' value='1'>You may only use constant extra space.

<br/></li><li id='VCCACAWEBy3' class=''>Recursive approach is fine, implicit stack space does not count as extra space for this problem.

<br/></li></ul></div><b>Example:</b><br/>

Given the following binary tree,<br/>

<pre id='VCCACActorv'>     1<br>   /  \<br>  2    3<br> / \    \<br>4   5    7</pre>

<br/>

After calling your function, the tree should look like:<br/>

<pre id='VCCACAKHFNW'>     1 -&gt; NULL<br>   /  \<br>  2 -&gt; 3 -&gt; NULL<br> / \    \<br>4-&gt; 5 -&gt; 7 -&gt; NULL</pre>

<pre id='VCCACAjTFtX'>class Solution:<br>    # @param root, a tree link node<br>    # @return nothing<br>    def connect(self, head, next_pointer = None):<br>        if not head:<br>            return<br>        head.next = next_pointer<br>        new_next_pointer = self.find_next_pointer(head.next)<br>        if head.right:<br>            self.connect(head.right, new_next_pointer) # tail recursion optimization<br>            self.connect(head.left, head.right)<br>            # https://www.zhihu.com/question/20761771<br>        else:<br>            self.connect(head.left, new_next_pointer)<br><br>    def find_next_pointer(self, next_node): # 3<br>        while next_node: # 3<br>            if next_node.left: return next_node.left<br>            if next_node.right: return next_node.right<br>            next_node = next_node.next<br>        return None</pre>

<b>Example: Copy List with Random Pointer</b><br/>

A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.<br/>

<pre id='VCCACASQfIk'>class Solution(object):<br>    def copyRandomList(self, head):<br><br>        # Insert each node's copy right after it, already copy .label<br>        node = head<br>        while node:<br>            copy = RandomListNode(node.label)<br>            copy.next = node.next<br>            node.next = copy<br>            node = copy.next<br><br>        # Set each copy's .random<br>        node = head<br>        while node:<br>            node.next.random = node.random and node.random.next<br>            node = node.next.next<br><br>        # Separate the copied list from the original, (re)setting every .next<br>        node = head<br>        copy = head_copy = head and head.next<br>        while node:<br>            node.next = node = copy.next<br>            copy.next = copy = node and node.next<br><br>        return head_copy</pre>

<h3 id='VCCACAC77OB'>3.3 COnnecting lists</h3>

One List can be rearrange to two; Two lists can be combined to one; Use Dummy Node here.<br/>

<br/>

<b>Example: Partition List</b><br/>

Given a linked list and a value <i>x</i>, partition it such that all nodes less than <i>x</i> come before nodes greater than or equal to <i>x</i>.<br/>

You should preserve the original relative order of the nodes in each of the two partitions.<br/>

<b><br>Input:</b> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, <i>x</i> = 3<br><b>Output:</b> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br/>

<pre id='VCCACAfE1bD'># Definition for singly-linked list.<br># class ListNode(object):<br>#     def __init__(self, x):<br>#         self.val = x<br>#         self.next = None<br><br>class Solution(object):<br>    def partition(self, head, x):<br>        """<br>        :type head: ListNode<br>        :type x: int<br>        :rtype: ListNode<br>        <br>        1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>        1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 1<br>        1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 5<br>        1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 6<br>        """<br>        left  = left_head  = ListNode(None)<br>        right = right_head = ListNode(None)<br>        cur = head<br>        while cur:<br>            cur_next = cur.next<br>            cur.next = None<br>            if cur.val &lt; x:<br>                left.next = cur<br>                left = cur<br>            else:<br>                right.next = cur<br>                right = cur<br>            cur = cur_next<br>        left.next = right_head.next<br>        return left_head.next<br>        <br>    def partitionWithoutDummy(self, head, x):<br>        """<br>        :type head: ListNode<br>        :type x: int<br>        :rtype: ListNode<br>        <br>        1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>        1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 1<br>        1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 5<br>        1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 6<br>        """<br>        left  = left_head  = None<br>        right = right_head = None<br>        cur = head<br>        while cur:<br>            cur_next = cur.next<br>            cur.next = None<br>            if cur.val &lt; x:<br>                if not left:<br>                    left = cur<br>                    left_head = cur<br>                else:<br>                    left.next = cur<br>                    left = cur<br>            else:<br>                if not right:<br>                    right = cur<br>                    right_head = cur<br>                else:<br>                    right.next = cur<br>                    right = cur<br>            cur = cur_next<br>        if left:<br>            left.next = right_head<br>            return left_head<br>        else:<br>            return right_head</pre>

<b>Example: Reverse Linked List II</b><br/>

Reverse a linked list from position <i>m</i> to <i>n</i>. Do it in one-pass.<br/>

<b>Note: </b>1 ≤ <i>m</i> ≤ <i>n</i> ≤ length of list.<br/>

<b>Example:</b><br/>

<pre id='VCCACAqzFbD'><b>Input:</b> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, <i>m</i> = 2, <i>n</i> = 4<br><b>Output:</b> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</pre>

<pre id='VCCACABzApn'>    def reverseBetween(self, head, m, n):<br>        if m == n:<br>            return head<br><br>        dummyNode = ListNode(0)<br>        dummyNode.next = head<br>        pre = dummyNode<br><br>        for i in range(m - 1):<br>            pre = pre.next<br>        <br>        # reverse the [m, n] nodes<br>        reverse = None<br>        cur = pre.next<br>        for i in range(n - m + 1):<br>            next = cur.next<br>            cur.next = reverse<br>            reverse = cur<br>            cur = next<br><br>        pre.next.next = cur<br>        pre.next = reverse<br><br>        return dummyNode.next</pre>

<pre id='VCCACAbsZ0g'>class SolutionWithoutDummy(object):<br>    def reverseBetween(self, head, m, n):<br>        """<br>        :type head: ListNode<br>        :type m: int<br>        :type n: int<br>        :rtype: ListNode<br>        <br>        [1,2,3,4,5]<br>        2<br>        4<br>        """<br>        if not head: return head<br>        cur  = head<br>        prev = None<br>        n = n - m<br>        while m &gt; 1:<br>            prev =  cur<br>            cur  =  cur.next<br>            m    -= 1<br>        if cur:<br>            reversed_sec, rest_sec = self.reverse_list(cur, n)<br>            cur.next = rest_sec<br>            if prev:<br>                prev.next = reversed_sec<br>            else: # if prev is None, then return the new head<br>                return reversed_sec<br>        return head<br><br>    def reverse_list(self, head, k):<br>        # input:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, 2<br>        # output: 3-&gt;2-&gt;1-&gt;NULL, 4-&gt;5-&gt;NULL<br>        prev = None<br>        cur  = head<br>        <br>        while cur:<br>            if k &gt;= 0:<br>                cur_next = cur.next<br>                cur.next = prev<br>                prev = cur<br>                cur  = cur_next<br>                k -= 1<br>            else:<br>                break<br>        return (prev, cur)</pre>

<h3 id='VCCACAvYZ5B'>3.4 Divide &amp; Conquer</h3>

T(n) = T(n/2) + O(1) = O(logn), <br>T(n) = T(n/2) + O(n) = O(n), <br/>

T(n) = <u><i><b>2T(n/2) + O(1) = = 2T(n/2) + c = O(n)</b></i></u>,  example ==&gt; n = 4<br>T(n) =<u><i><b> 2T(n/2) + O(n) = O(n*logn)</b></i></u> example n = 4 ==&gt; 4log4<br/>

The last divide &amp; conquer can generate a n*logn<br/>

<br/>

<b>Example: Merge k Sorted Array List</b><br/>

Merge <i>k</i> sorted array lists and return it as one sorted list. Analyze and describe its complexity.<br/>

Time complexity: O(n*logk)<br/>

<pre id='VCCACAnSIij'><b>Input: </b>[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ]<br><b>Output:</b> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</pre>

<pre id='VCCACARlbz8'># Array List Based<br>class Solution:<br>    def two_list_merge(self, a, b):<br>        # a = [], b = [1]<br>        # a = [1, 3], b = [2, 4]<br>        i, j = 0, 0<br>        result = []<br>        while i &lt; len(a) and j &lt; len(b):<br>            if a[i] &lt; b[j]:<br>                result.append(a[i])<br>                i += 1<br>            else:<br>                result.append(b[j])<br>                j += 1<br>        if i &lt; len(a):<br>            result += a[i:]<br>        if j &lt; len(b):<br>            result += b[j:]<br>        return result<br>            <br>    def merge(self, lists, start, end):<br>        """<br>        *Input: *[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ]<br>*        Output:* 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>        """<br>        if start &gt; end: return []<br>        if start == end:<br>            return lists[start]<br>        mid   = (start + end) // 2<br>        left  = self.merge(lists, start,   mid)<br>        right = self.merge(lists, mid + 1, end)<br>        return self.two_list_merge(left, right)<br>    <br>    def mergeKLists(self, lists):<br>        """<br>        :type lists: List[ListNode]<br>        :rtype: ListNode<br>        O R T<br>        """<br>        return self.merge(lists, 0, len(lists) - 1)<br>s = Solution()<br>print(s.mergeKLists([[1,4,5],[1,3,4],[2,6]]))</pre>

<h2 id='VCCACAwCpYC'>Topic 4: <b>String &amp; List</b></h2>

<h3 id='VCCACAMyvWS'>4.1 KMP - String Match</h3>

<b>Example: Implement strStr()  --- KMP algorithm</b><br>Return the index of the first occurrence of pattern in text, or -1 if pattern is not part of text. <br>Next Table:<br/>

<div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/EUdROxsm5SK0sAYil8l5UA?a=vbMXJtsnohoLG1l0FjNLUARQXfyvUCb1JQR0fQyhZAca' id='VCCACAjichR' alt=''></img></div><div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/rnB2NzoEadzDYtZrOImRpA?a=7vdm9YfMcNO2J4NXZTeuAVZDZHa7xojCt72krQlsHKga' id='VCCACA2R0cQ' alt=''></img></div><br/>

<div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/Kl9PNmSLBLsfXk0oyqEszQ?a=U5VJoQualaOL4UKGnjUmbqe5gFil5LlLayDVnQ9vVwwa' id='VCCACACs86I' alt=''></img></div>移动位数 = 已匹配的字符数 - 对应的部分匹配值<br/>

"部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度<br>以"ABCDABD"为例<br>－ "A"的前缀和后缀都为空集，共有元素的长度为0；<br/>

－ "AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；<br/>

－ "ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；<br/>

－ "ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；<br/>

－ "ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；<br/>

－ "ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；<br/>

－ "ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。<br/>

<br/>

0是指下一个要去比较的是patter[0], 1是指下一个要去比较的是patter[1]<br/>

<pre id='VCCACAKwUn6'>def compute_prefix_function(pattern):<br>    next_table = [0] * len(pattern)<br>    k = 0 # k is the next char to compare in pattern<br>    for q in range(1, len(pattern)):<br>        while k &gt; 0 and pattern[k] != pattern[q]:<br>            k = next_table[k - 1]<br>        if pattern[k] == pattern[q]:<br>            k = k + 1<br>        next_table[q] = k<br>    return next_table<br><br>def kmp_match(text, pattern):<br>    next_table = compute_prefix_function(pattern)<br>    q = 0 # q is the next char to compare in pattern<br>    for i in range(len(text)):<br>        while q &gt; 0 and pattern[q] != text[i]:<br>            q = next_table[q - 1]<br>        if pattern[q] == text[i]:<br>            q = q + 1<br>        if q == len(pattern):<br>            return i - len(pattern) + 1<br>            # return the start idx of the matched pattern<br>    return -1 # not found<br><br>text    = 'BBC ABCDAB ABCDABCDABDE'<br>pattern = 'ABCDABD'<br>print(compute_prefix_function(pattern))<br># [0, 0, 0, 0, 1, 2, 0]<br>print(kmp_match(text, pattern)) <br># Expect to be idx 15</pre>

<h2 id='VCCACAs4I0p'>Topic 5: <b>HashMap</b></h2>

<b><b>Want to have all O(1)? – How to implement HashMap?<br> A Hash Table dictionary contains: an array A with size M, key-value pairs, hash function<br> Operations: search(k) </b></b>– <b>insert (k, v), search (k) </b>return value of k / not exist<b>, update (k, v), delete(k)</b><br/>

<br/>

Key Concerns: <br>  (1) <u><i><b>Hash function</b></i></u> - what if keys are not integers?<br>  (2)<u><i><b> Good Hashing</b></i></u> - it maps the keys in our map so as to sufficiently minimize collisions<br>        <u><i><b>Collection Handling</b></i></u>: If collection happens - how to handle collection? (Chaining or Open-Hashing)<br>  (3) When and how to <u><i><b>extend the array when there are too many collisions </b></i></u>(too many numbers)?<br><br><br><b><b>Concern1: Hash Functions = Hash code function + Compression function</b></b><br/>

arrayIdx to place = hashcode % module len(capacity of array) - 1<br/>

<br/>

<b><b>Concern2: Chaining (bucketing) or Open-addressing</b></b><br/>

<br/>

Chaining: Store the item (k,v) in the bucket A[h(k)].<br> Open-addressing: If we try to insert an item (k,v) into a bucket A[j] that is already occupied, where j = h(k), then <br>    we next try A[(j+1) mod N]. If A[(j+1) mod N] is also occupied, then we try A[( j+2) mod N], and so on, <br>    until we find an empty bucket that can accept the new item. <br/>

<u>In open-addressing, to implement a deletion, we cannot simply remove a found item</u> from its slot in the array. For example, after the insertion of key 15, if the item with key 37 were trivially deleted, a subsequent search for 15 would fail because that search would start by probing at index 4, then index 5, and then index 6, at which an empty cell is found. <u>A typical way to get around this difficulty is to replace a deleted item with a special </u><u>“</u><u>available</u><u>”</u><u> marker object.</u><br/>

<br/>

<u>Open-addressing is usually faster than chained hashing when the load factor is low</u> because you don't have to follow pointers between list nodes. <u>It gets very, very slow if the load factor approaches 1, </u>because you end up usually having to search through many of the slots in the bucket array before you find either the key that you were looking for or an empty slot. Also, <u>you can never have more elements in the hash table than there are entries in the bucket array.</u><br/>

<br/>

<b><b>Concern2: Load Factor (Extend the array &amp; Rehashing)</b></b><br> In the hash table schemes described thus far, it is important that the load factor, L= n/N, be kept below 1,<br>                                                                                         n == current hashtable length, N == hashtable capacity<br>                                                                                       Since we want to have expected collection to be 1<br> In Java, Default initial capacity of the HashMap takes is 16 and load factor is 0.75f (i.e 75% of current map size). <br> In Python load factor is 0.5, If the load factor of the table increases beyond 0.5, we double the size of the table and rehash all items into the new table.<br/>

<div data-section-style='11' style='max-width:100%'><img src='https://quip.com/blob/VCCAAAgSiOv/bCg0Y7SM1ltk55C8QcJWbQ?a=19fd5fK9ohB1hau6vXGCvPPhIonQC1aZfimaz8YLeGAa' id='VCCACAM7YJA' alt=''></img></div><br/>

<br/>

<h2 id='VCCACA7nQXO'>Practice</h2>

<b>Review: List Operators in Python</b><br/>

<pre id='VCCACAPz7VL'>list.append(x)<br><br>list.extend(L)<br>  equivalent to a[len(a):] = L.<br><br>list.insert(i, x)<br> The first argument is the index of the element before which to insert<br> so a.insert(0, x) inserts at the front of the list, <br> and a.insert(len(a), x) is equivalent to a.append(x).<br><br>list.remove(x)<br> Remove the first item from the list whose value is x. <br> It is an error if there is no such item.<br><br>list.pop([i])<br> Remove the item at the given position in the list, and return it. <br> If no index is specified, a.pop() removes and returns the last item in the list.<br><br>list.index(x)<br> Return the index in the list of the first item whose value is x. <br> It is an error if there is no such item.<br><br>list.count(x)<br> Return the number of times x appears in the list.<br><br>list.sort(cmp=None, key=None, reverse=False)<br> Sort the items of the list in place <br> (the arguments can be used for sort customization, <br>   see sorted() for their explanation).<br><br>list.reverse()<br> Reverse the elements of the list, in place. which equals to list[::-1]<br> <br>collections.deque.append(x)<br> Add x to the right side of the deque.<br><br>collections.deque.appendleft(x)<br> Add x to the left side of the deque.<br><br>collections.deque.clear()<br> Remove all elements from the deque leaving it with length 0.<br> <br>collections.deque.count(x)<br> Count the number of deque elements equal to x.<br><br>collections.deque.extend(iterable)<br><br>collections.deque.extendleft(iterable)<br><br>collections.deque.index(x[, start[, stop]])<br> Returns the first match or raises ValueError if not found.<br><br><code>colle</code>ctions.deque.pop()<br><br>collections.deque.popleft()<br><br>collections.deque.remove(value)<br> Remove the first occurrence of value. If not found, raises a ValueError.<br><br>collections.deque.reverse()<br> Reverse the elements of the deque in-place and then return None.</pre>

<b>Q1: Add Two Numbers II</b><br/>

You are given two <b>non-empty</b> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br/>

You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br/>

<pre id='VCCACAROX7i'><b>Input:</b> (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><b>Output:</b> 7 -&gt; 8 -&gt; 0 -&gt; 7</pre>

<pre id='VCCACA4ROF7'># Definition for singly-linked list.<br># class ListNode(object):<br>#     def __init__(self, x):<br>#         self.val = x<br>#         self.next = None<br><br>class Solution(object):<br>    def lsize(self, l):<br>        n = 0<br>        while l:<br>            l = l.next<br>            n += 1<br>        return n<br>    <br>    def reverse_lst(self, l):<br>        prev = None<br>        cur  = l<br>        while cur:<br>            cur_next = cur.next<br>            cur.next = prev<br>            prev = cur<br>            cur = cur_next<br>        return prev<br>    <br>    def addTwoNumbers(self, l1, l2):<br>        """<br>        :type l1: ListNode<br>        :type l2: ListNode<br>        :rtype: ListNode<br>        """<br>        m, n = self.lsize(l1), self.lsize(l2)<br>        if m &lt; n:<br>            return self.addTwoNumbers(l2, l1)<br>        <br>        reversed_l1, reversed_l2 = self.reverse_lst(l1), self.reverse_lst(l2)<br>        l1_dummy             = <u><i><b>ListNode(0)</b></i></u><br>        l1.next              = l1_dummy<br>        l_cur,r_cur          = reversed_l1, reversed_l2<br>        carry                = 0<br>        <br>        <u><i><b>while l_cur:</b></i></u><br>            <u><i><b>if r_cur:</b></i></u><br>                <u><i><b>l_cur</b></i></u><u><i><b>.val += (r_cur.val + carry)</b></i></u><br>                <u><i><b>r_cur </b></i></u><u><i><b>= r_cur.next</b></i></u><br>            <u><i><b>else:</b></i></u><br>                <u><i><b>l_cur</b></i></u><u><i><b>.val += carry</b></i></u><br>                <br>            carry     = l_cur.val // 10<br>            l_cur.val = l_cur.val % 10<br>            l_cur = l_cur.next<br>            <br>        if l1_dummy.val == 0:<br>            l1.next = None<br>            <br>        return self.reverse_lst(reversed_l1)</pre>

<pre id='VCCACAh5ZIX'><b>from </b>collections <b>import </b>Counter<br><br><b>"""</b><b>1. Given an array and a target, return the number of pairs whose <br>sum is the target.</b><b>10/12/2018 21:00</b><b>Idea: For special cases, list example<br> and calculate the correct answer by math.<br> </b><b>https://www.geeksforgeeks.org/count-pairs-with-given-sum/</b><b>"""<br> <br> </b><i># [1, 2, 4, 5, 3, 1, 2, 0] t = 4 =&gt; (4, 0), (3, 1), (3, 1), (2, 2)<br> </i>print(<b>"1. count_pair (dict)"</b>)<br><br><b>def </b>count_pair(nums, t):<br>    count_dict = Counter(nums)<br><br>    <i># say t = 4, there are 5 times of 2</i><i>    # first 2, pair with other 4 times of 2</i><i>    # second 2, pair with other 3 times of 2</i><i>    # ....</i><i>    # (5 - 1) + .... + 0</i><i>    # (5 - 1) * 5 // 2</i><i>    </i>res = 0    <b>for </b>n <b>in </b>nums:<br>        res += count_dict[t - n]<br>        <b>if </b>2 * n == t:<br>            res -= 1    <b>return </b>res // 2print(count_pair([1, 2, 4, 5, 3, 1, 2, 0], 4))<br><br>print()<br><br><b>"""</b><b>2. Given nums and v, return index i where i is the largest index for nums[i] &lt;= v</b><b>"""</b>print(<b>"2. get_lower_bound"</b>)<br><br><b>def </b>get_lower_bound(nums, v):<br>    <i># return index i where i is the smallest index for nums[i] &gt;= v</i><i>   <br>    # just use l</i><i>    <br>    # nums is sorted</i><i>    <br>    # [1, 2, 3, 4, 5]</i><i>    <br>    # v = 3 --&gt;</i><i>    <br>    #  l = 2 (pointing 3 which is just &gt;= v),</i><i>    <br>    #  r = 1 (pointing 2, which is pointing the last element &lt; v)</i><i>    <br>    # [1, 2, 3, 3, 5]</i><i>    <br>    # v = 3 --&gt;</i><i>    <br>    #  l = 2 (pointing 3 which is just &gt;= v),</i><i>    <br>    #  r = 1 (pointing 2, which is pointing the last element &lt; v)</i><i>    <br>    # [1, 2, 3, 3, 5]</i><i>    <br>    # v = 4</i><i>    <br>    #  l = 4 (pointing 5 which is just &gt; v),</i><i>    <br>    #  r = 3 (pointing 3, which is pointing the last element &lt; v)</i><i>    <br>    # [1, 2, 3, 3, 5]</i><i>    <br>    # v = 6</i><i>    <br>    #  l = 5 (OUT OF BOUND),</i><i>    <br>    #  r = 4 (pointing 3, which is pointing the last element &lt; v)</i><i>    <br>    # [1, 2, 3, 3, 5]</i><i>    <br>    # v = 0</i><i>    <br>    #  l = 0 (pointing 5 which is just &gt;= v),</i><i>    <br>    #  r = -1 (OUT OF BOUND)</i><i>    <br>    # [1, 2, 3, 3, 5]</i><i>    <br>    # v = 1</i><i>    <br>    #  l = 0 (pointing 2 which is just &gt;= v),</i><i>    <br>    #  r = -1 (OUTOFBOUND, which is pointing the last element &lt; v)</i><i>    <br>    # [1, 2, 3, 3, 5]</i><i>    <br>    # v = 5</i><i>    <br>    #  l = 4</i><i>    <br>    #  r = 3 (which is pointing the last element &lt; v)</i><i>    <br>    #  </i>n = len(nums)<br>    l = 0    r = n - 1    <b>while </b>l &lt;= r:<br>        mid = (l + r) // 2        <br>        <i># mid keeps increasing, 0 &lt;= mid &lt;= n - 1</i><i>        <br>        </i><b>if </b>nums[mid] &lt; v: <i># !!! &lt;</i><i>            <br>            </i>l = mid + 1        <br>              <b>else</b>:<br>            r = mid - 1    <br>    <b>return </b>l, r<br><br>print(get_lower_bound([1, 2, 3, 4, 5], 3))<br>print(get_lower_bound([1, 2, 3, 3, 5], 3))<br>print(get_lower_bound([1, 2, 3, 3, 5], 4))<br>print(get_lower_bound([1, 2, 3, 3, 5], 6))<br>print(get_lower_bound([1, 2, 3, 3, 5], 0))<br>print(get_lower_bound([1, 2, 3, 3, 5], 1))<br>print(get_lower_bound([1, 2, 3, 3, 5], 5))<br><br>print()<br><b>"""</b><b>2. Given nums and v, return index i where i is the largest index for nums[i] &lt;= v</b><b>"""</b>print(<b>"3. get_upper_bound"</b>)<br><b>def </b>get_upper_bound(nums, v):<br>    <i># return index i where i is the largest index for nums[i] &lt;= v</i><i>    # just use r</i><i>    # nums is sorted</i><i>    # [1, 2, 3, 4, 5]</i><i>    # v = 3 --&gt;</i><i>    #  l = 3 (pointing 4 which is just &gt; v),</i><i>    #  r = 2 (pointing 3, which is pointing the last element &lt;= v)</i><i>    # [1, 2, 3, 3, 5]</i><i>    # v = 3 --&gt;</i><i>    #  l = 4 (pointing 5 which is just &gt; v),</i><i>    #  r = 3 (pointing 3, which is pointing the last element &lt;= v)</i><i>    # [1, 2, 3, 3, 5]</i><i>    # v = 4</i><i>    #  l = 4 (pointing 5 which is just &gt; v),</i><i>    #  r = 3 (pointing 3, which is pointing the last element &lt;= v)</i><i>    # [1, 2, 3, 3, 5]</i><i>    # v = 6</i><i>    #  l = 5 (OUT OF BOUND),</i><i>    #  r = 4 (pointing 3, which is pointing the last element &lt;= v)</i><i>    # [1, 2, 3, 3, 5]</i><i>    # v = 0</i><i>    #  l = 0 (pointing 5 which is just &gt; v),</i><i>    #  r = -1 (OUT OF BOUND)</i><i>    # [1, 2, 3, 3, 5]</i><i>    # v = 1</i><i>    #  l = 1 (pointing 2 which is just &gt; v),</i><i>    #  r = 0</i><i>    # [1, 2, 3, 3, 5]</i><i>    # v = 5</i><i>    #  l = 5</i><i>    #  r = 4</i><i>    </i>n = len(nums)<br>    l = 0    r = n - 1    <b>while </b>l &lt;= r:<br>        mid = (l + r) // 2        <i># mid keeps increasing, 0 &lt;= mid &lt;= n - 1</i><i>        </i><b>if </b>nums[mid] &lt;= v: <i>#!!! &lt;=</i><i>            </i>l = mid + 1        <b>else</b>:<br>            r = mid - 1    <b>return </b>l, r<br><br>print(get_upper_bound([1, 2, 3, 4, 5], 3))<br>print(get_upper_bound([1, 2, 3, 3, 5], 3))<br>print(get_upper_bound([1, 2, 3, 3, 5], 4))<br>print(get_upper_bound([1, 2, 3, 3, 5], 6))<br>print(get_upper_bound([1, 2, 3, 3, 5], 0))<br>print(get_upper_bound([1, 2, 3, 3, 5], 1))<br>print(get_upper_bound([1, 2, 3, 3, 5], 5))<br><br>print()<br><br><b>"""</b><b>4. Binary Search binary_search (nums, target)</b><b>"""</b><b>def </b>binary_search(nums, target):<br>    n = len(nums)<br>    l = 0    r = n - 1 <i># use the get_upper_bound template</i><i>    </i><b>while </b>l &lt;= r:<br>        mid = (l + r) // 2        <b>if </b>nums[mid] &lt;= target:<br>            l = mid + 1        <b>else</b>:<br>            r = mid - 1    <b>if </b>r &lt; 0 <b>or </b>nums[r] != target: <b>return </b>-1 <i># !!!!!!</i><i>    </i><b>return </b>r<br><br>print(<b>"4. binary_search"</b>)<br>print()<br><br><b>"""</b><b>5. return [start, end] such that if the range is sorted, then the whole array is sorted. </b><b>[1, 2, 3, 5, 4, 6, 7] =&gt; [3, 4] </b><b>[1, 2, 3, 6, 1, 2, 5] =&gt; [1, 6]</b><b>[1, 2, 3, 6, 3, 2, 5, 7, 6] =&gt; [2, 8]</b><b>https://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/</b><b>Idea: Base Case -&gt; Improve Time Complexity</b><b>What if not exists -- -1</b><b>Base Solution: O(n*logn) by sorting</b><b>"""</b><i># get_range([1, 2, 3, 5, 4, 6, 7, 8, 9, 7, 10])  # [2, 4]</i>print(<b>"5. get_range"</b>)<br><br><b>def </b>get_range(nums):<br>    n = len(nums)<br>    range_l = -1    range_r = -1    max_sofar = nums[0]<br><br>    <b>for </b>i, num <b>in </b>enumerate(nums):<br>        <b>if </b>num &lt; max_sofar:<br>            <i># unsorted starting at i</i><i>            </i><b>if </b>range_l == -1:<br>                range_l = get_upper_bound(nums, min(nums[i:]))[0]<br>            range_r = i<br>        <b>else</b>:<br>            max_sofar = num<br>    <b>return </b>range_l, range_r<br><br>print(get_range([1, 2, 3, 5, 4, 6, 7]))<br>print(get_range([1, 2, 3, 6, 1, 2, 5]))<br>print(get_range([1, 2, 3, 6, 3, 2, 5, 7, 6]))<br>print(get_range([10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60])) <i># (3. 8)</i>print()</pre>

<pre id='VCCACAkl9vn'><br>"""<br>6. Find the integer x appears more than n/k times in a sorted array of n integers. <br>Return None if not exists<br><br>Test Cases Build:<br>[1, 2, 3, 4]<br>[1, 2, 3, 4, 5, 6, 6]<br>[1, 2, 2, 4, 5, 6, 6]<br>[1, 2, 2, 4, 6, 6, 7]<br><br>Found out there might be multiple solutions -&gt; return a list of solutions<br>1. 对于满足条件的数，一定只会出现在0, 1 * length / k, 2 * length / k, 3 * length / k, ... , min( k * length / k, length - 1), 注意最后的边界要取一个较小值。<br>2. 对于条件2中的数字，利用二分法找到第一个出现的位置和最后一个出现的位置，只要次数 &gt;= length / k，就加入到结果中。<br><br>s = n // 4<br><br>Utilize the properity "sorted" to help solving the problem.<br>--&gt; What difference will make if the array is sorted.<br><br>"""<br><br>print("6. find_popular (binary search)")<br><br><br>def find_first(items, i, j, n):<br>    # find the first idx of occurance<br>    first = -1<br>    while i &lt;= j:<br>        mid = (i + j) &gt;&gt; 1<br>        if items[mid] &lt; n:<br>            i = mid + 1<br>        elif items[mid] == n:<br>            first = mid<br>            j = mid - 1<br>        else:<br>            j = mid - 1<br>    return first<br><br><br>def find_last(items, i, j, n):<br>    # find the last idx of occurance<br>    last = -1<br>    while i &lt;= j:<br>        mid = (i + j) &gt;&gt; 1<br>        if items[mid] &lt; n:<br>            i = mid + 1<br>        elif items[mid] == n:<br>            last = mid<br>            i = mid + 1<br>        else:<br>            j = mid - 1<br>    return last<br><br># First Implementation: find at most 2*k points<br># 2*k*log(n)<br><br>def find_popular(nums, k):<br>    n = len(nums)<br>    res_set = set()<br>    freq = n // k<br>    bounds = [i * freq for i in range(2 * k) if i * freq &lt;= n - 1]<br>    # add right-most boundary<br>    # bounds.append(n - 1)<br>    candidates = [nums[i] for i in bounds]<br>    for i in range(1, len(candidates) - 1):<br>        first = find_first(nums, bounds[i - 1], bounds[i], candidates[i])<br>        last = find_last(nums, bounds[i], bounds[i + 1], candidates[i])<br>        # because boundaries are included<br>        # candidate must be found<br>        if last - first + 1 &gt; freq:<br>            # we use set because candidates may be the same<br>            res_set.add(candidates[i])<br>    return res_set<br><br>print(find_popular([1, 2, 2, 4, 6, 6, 7], 4)) # {2, 6}<br>print(find_popular([1, 2, 2, 4, 6, 7, 7], 4)) # {2, 7}<br><br><br># Second Implementation: find at most 2*k points<br># 2*k*(2*k)<br># For each point, look around the k before and k after points.<br><br>print()<br><br>"""<br>Merge sort without recursion<br>"""<br><br>print("7. Iterative Merge Sort")<br><br>print()<br><br><br>"""<br>Merge sort without recursion<br>"""<br><br>print("8. Rotate Matrix (matrix)")<br>class Solution(object):<br>    def rotate(self, matrix):<br>        """<br>        :type matrix: List[List[int]]<br>        :rtype: void Do not return anything, modify matrix in-place instead.<br>        """<br>        for row in range(len(matrix) / 2):<br>            for column in range((len(matrix) + 1)/ 2):<br>                a = matrix[row][column]<br>                b = matrix[column][len(matrix) - 1 - row]<br>                c = matrix[len(matrix) - 1 - row][len(matrix) - 1 - column]<br>                d = matrix[len(matrix) - 1 - column][row]<br>                matrix[row][column] = d<br>                matrix[column][len(matrix) - 1 - row] = a<br>                matrix[len(matrix) - 1 - row][len(matrix) - 1 - column] = b<br>                matrix[len(matrix) - 1 - column][row] = c<br><br>print()<br><br>print("9. K Inverse Pairs Array (DP)")<br><br>def kInversePairs(n, k):<br>    """<br>    n = 1<br>    [1]<br><br>    n = 2<br>    [1, 2] [2, 1]<br>        k = 1 [2, 1]<br><br>    n = 3<br>    [1, 2, 3] [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]<br>        k = 1  [1,3,2]   and [2,1,3]<br>        k = 1  [3, 1, 2] and [2,3,1]<br><br><br>    n = 4<br>        k = 3<br>    [3, 2, 1. 4], [3, 1, 4, 2], [2, 3, 4, 1],  [1, 4, 3, 2]. [2, 4, 1, 3], [4, 1, 2, 3],<br>    [4, 1, 3, 2], [4, 3, 1, 2] (5 pairs), [4, 3, 2, 1] (6 pairs)<br>    kInversePairs(self, n, k) =<br>        kInversePairs(n, k - 1) + kInversePairs(n - 1, k)<br><br>    P(n,r) = n! / (n−r)!<br>    C(n,r) = n! / ((n−r)! * r!)<br><br>    """<br>    states = [1] + [0] * k # for n = 0, [0, k] pairs<br>    for i in range(1, n + 1):<br>        next_states = [1] + [0] * k<br>        for j in range(1, k + 1):<br>            next_states[j] = next_states[j - 1] + states[j]<br>            if j - 1 - (i - 1) &gt;= 0:<br>                next_states[j] -= states[j - 1 - (i - 1)]<br>        states = next_states<br>    return states[k] % (10 ** 9 + 7)<br><br>def kInversePairsComplex(n, k):<br>    """<br>    :type n: int<br>    :type k: int<br>    :rtype: int<br>    """<br>    max_k = n * (n - 1) // 2<br>    if k &gt; max_k: return 0<br>    # states = [[0 for _ in range(max_k + 1)] for _ in range(n + 1)]<br>    states = [[0 for _ in range(max_k + 1)] for _ in range(2)]<br><br>    cur_row = 0<br>    states[0][0] = 1<br><br>    for i in range(1, n + 1):<br>        new_row = (cur_row + 1) % 2<br>        states[new_row][0] = 1<br>        for j in range(1, min(i * (i - 1) // 2 + 1, k + 1)):<br>            # states[new_row][j] = sum([states[cur_row][k] for k in range((j - i + 1), j + 1)])<br>            states[new_row][j] = states[new_row][j - 1] - states[cur_row][j - 1 - (i - 1)] + states[cur_row][j]<br>        cur_row = new_row<br>    return states[cur_row][k] % (10 ** 9 + 7)<br><br>print()<br><br>print("10. Longest Consecutive Sequence (Set / Union Find)")<br><br>from collections import Counter<br><br>class Solution:<br>    def longestConsecutive(self, nums):<br>        nums_set = set(nums)<br>        res = 0<br>        for num in nums:<br>            cluster_size = 0<br>            n = num<br>            while True:<br>                if n in nums_set:<br>                    nums_set.remove(n)<br>                else:<br>                    break<br>                cluster_size += 1<br>                n -= 1<br>            n = num + 1<br>            while True:<br>                if n in nums_set:<br>                    nums_set.remove(n)<br>                else:<br>                    break<br>                cluster_size += 1<br>                n += 1<br>            res = max(res, cluster_size)<br>        return res<br><br>    """<br>    Complexity of union-find with path-compression, without rank. <br>    Union by rank without path compression<br>         gives an amortized time complexity of O (log n)<br>    Union by rank with path compression<br>         gives an amortized time complexity of O(1) &lt; &lt; O(logn)<br>    """<br><br>    def find(self, x):<br>        y = x<br>        while self.parents[y] != y:<br>            y = self.parents[y]<br>        self.parents[x] = y<br>        return y<br><br>    def union(self, x, y):<br>        parent_x = self.find(x)<br>        parent_y = self.find(y)<br>        if parent_x != parent_y:<br>            self.parents[parent_x] = parent_y<br><br>    def longestConsecutiveUnionFind(self, nums):<br>        """<br>        :type nums: List[int]<br>        :rtype: int<br>        """<br>        nums = list(set(nums))<br>        self.parents = dict(zip(nums, nums))<br>        for num in nums:<br>            if num - 1 in self.parents:<br>                self.union(num - 1, num)<br>            if num + 1 in self.parents:<br>                self.union(num + 1, num)<br>        count = Counter([self.find(n) for n in nums])<br>        return max(count.values() or [0])<br><br>print()</pre>

<pre id='VCCACAikRh8'># Python merge sort in place, so space complexity is O(1)<br><br>def merge_sort(xs):<br>    """Inplace merge sort of array without recursive. The basic idea<br>    is to avoid the recursive call while using iterative solution. <br>    The algorithm first merge chunk of length of 2, then merge chunks<br>    of length 4, then 8, 16, .... , until 2^k where 2^k is large than <br>    the length of the array<br>    """<br><br>    unit = 1<br>    while unit &lt;= len(xs):<br>        h = 0<br>        for h in range(0, len(xs), unit * 2):<br>            l, r = h, min(len(xs), h + 2 * unit)<br>            mid = h + unit<br>            # merge xs[h:h + 2 * unit]<br>            p, q = l, mid<br>            while p &lt; mid and q &lt; r:<br>                if xs[p] &lt; xs[q]: p += 1<br>                else:<br>                    tmp = xs[q]<br>                    xs[p + 1: q + 1] = xs[p:q]<br>                    xs[p] = tmp<br>                    p, mid, q = p + 1, mid + 1, q + 1<br>        unit *= 2<br>    <br>    return xs</pre>

<br/>

</body></html>